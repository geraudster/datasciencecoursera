# Analysis of types of severe weather events that have most impacted the population and the economics in the United States from 1950 to 2011

## Synopsis

In this report we aim to describe the types of severe weather events that had the most impact on the population
and on the economics.
To perform this analysis, we used data from the U.S. National Oceanic and Atmospheric Administration's (NOAA) storm database.
This database contains data from 1950 to 2011 tracks major storms and weather events (like avalanche, dense fog, tsunami...).

TO BE CONTINUED...

Before we start, we load the required libraries:

``` {r}
library(R.utils) # used for bunzip2
library(ggplot2)
library(plyr)
library(reshape)
source("multiplot.R")
```

## Data Processing

* The data is located at https://d396qusza40orc.cloudfront.net/repdata%2Fdata%2FStormData.csv.bz2.
* The description is here: https://d396qusza40orc.cloudfront.net/repdata%2Fpeer2_doc%2Fpd01016005curr.pdf
* The code book is here: http://www1.ncdc.noaa.gov/pub/data/swdi/stormevents/csvfiles/Storm-Data-Export-Format.docx

Let's retrieve and uncompress the data from the Coursera's site:

```{r,cache=TRUE}
url <- "https://d396qusza40orc.cloudfront.net/repdata%2Fdata%2FStormData.csv.bz2"
datadir <- "data"
zipdatafile <- paste(datadir, "StormData.csv.bz2", sep="/")
if(!file.exists(zipdatafile)) {
    if(!file.exists(datadir)) { dir.create(datadir) }
    download.file(url, destfile=zipdatafile, method="curl")
}

datafile <- paste(datadir, "StormData.csv", sep="/")
bunzip2(zipdatafile, destname=datafile, remove=FALSE, overwrite=TRUE)
```

Then we load the data in R (might take several minutes...):
```{r,cache=TRUE}
data <- read.csv(datafile)
```

The data contains `r nrow(data)` observations of `r ncol(data)` variables. On our environment it takes `r format(object.size(data), units= "MB")` of memory.

Here is a small insight of what the data look like:
```{r}
head(data)
str(data)
summary(data$EVTYPE)
```

The interesting fields in this datasets are:

* EVTYPE: the type of severe event
* FATALITIES and INJURIES: the fatalities and injuries due to the event
* PROPDMG: estimated amount of damage to property (in $)
* CROPDMG: estimated amount of damage to crops (in $)
* PROPDMGEXP: the exponent to be applied. Levels are:
```{r}
levels(data$PROPDMGEXP)
```

* CROPDMGEXP: the exponent to be applied. Levels are:
```{r}
levels(data$CROPDMGEXP)
```

Concerning the exponents, we will ignore special characters (-, ?, +)
* B = billions
* M/m = millions
* K/k = thousands
* H/h = hundreds
* numeric value = $10^\\value$

Let's create a function to calculate the correct amount given an exponent:
```{r}
# first we define a correspondance table for the unit
expUnitTable <- data.frame(unit=c("h", "k", "m", "b"), weight=c(10^2, 10^3, 10^6, 10^9))

# the function itself
calculateExponent <- function(value, exponent) {
    # we set the default value for a weight to 1, so we will keep the value as is
    weight <- 1
    # check if the exponent is a number
    if(!is.na(as.numeric(exponent))) {
        weight <- 10 ^ as.numeric(exponent)
    } else {
        # get the weight associated with the unit. If not present, we got a numeric(0)
        weight <- expUnitTable$weight[expUnitTable$unit == tolower(exponent)]
        
        # if the unit is not in the table, reset the default value
        if(length(weight) == 0) {
            weight <- 1;
        }
    }
    value * weight
}
```

We prepare two tidy datasets: one for analysing the most harmful events, and the other for analysing
the greatest economic consequences.
```{r,cache=TRUE}
dataForHarm <- data[c("EVTYPE", "FATALITIES", "INJURIES")]
dataForEconomics <- data[c("EVTYPE", "CROPDMG", "CROPDMGEXP", "PROPDMG", "PROPDMGEXP")]
```

As we are interesting in finding the most harmful events, we can clean 
our datasets by removing all zero or undefined values in the fields.
```{r}
tidyDataForHarm <- dataForHarm[ dataForHarm$FATALITIES != 0 & dataForHarm$INJURIES != 0,]
nrow(tidyDataForHarm)

tidyDataForEconomics <- dataForEconomics [ dataForEconomics$CROPDMG != 0 & dataForEconomics$PROPDMG != 0,]
nrow(tidyDataForEconomics)
```

Then we add 2 columns to the economics dataset that compute a usable form of the amount of damage:
```{r}
tidyDataForEconomics <- transform(tidyDataForEconomics,
                                  cropDmgAmount = mapply(calculateExponent,
                                                         as.numeric(CROPDMG),
                                                         CROPDMGEXP),
                                  propDmgAmount = mapply(calculateExponent,
                                                         as.numeric(PROPDMG),
                                                         PROPDMGEXP))
```

Next, we'll plot the 10 most recensed events:
```{r,fig.width=9}
sumByEvt <- ddply(data, .(EVTYPE), summarize, count = length(EVTYPE))
sumByEvt[order(sumByEvt$count, decreasing=TRUE),][1:10,]
```

## Results

### Most harmful types of storm events

We'll use the tidyDataForHarm dataset. 

First we perform some aggregation based on the EVTYPE:
```{r}
aggregatesForHarm <- ddply(tidyDataForHarm, .(EVTYPE),
                           summarize,
                           fatalitiesTotal=sum(FATALITIES, na.rm=TRUE),
                           injuriesTotal=sum(INJURIES, na.rm=TRUE))

aggregatesForHarm$total <- aggregatesForHarm$fatalitiesTotal + aggregatesForHarm$injuriesTotal

meltAggregatesHarmful <- melt(aggregatesForHarm, id=c("EVTYPE", "total"))
meltAggregatesHarmful <- transform(meltAggregatesHarmful, EVTYPE = reorder(EVTYPE, total))
top <- head(meltAggregatesHarmful[order(meltAggregatesHarmful$total, decreasing=TRUE),], 20)

gHarmful <- ggplot(top, aes(x=EVTYPE, fill=variable, y=value)) +
    geom_histogram(stat="identity") +
    coord_flip(ylim=c(0,10000)) +
    geom_text(data=top[2,], aes(x=EVTYPE, y=8000, label=paste(value, "injuries")))
gHarmful
```

### Most economical impact

```{r}
aggregatesForEco <- ddply(tidyDataForEconomics, .(EVTYPE),
                           summarize,
                           cropDmgAmountTotal=sum(cropDmgAmount, na.rm=TRUE),
                           propDmgAmountTotal=sum(propDmgAmount, na.rm=TRUE))

#aggregatesForEco$total <- aggregatesForEco$cropDmgAmountTotal + aggregatesForEco$propDmgAmountTotal


meltAggregatesEco <- melt(aggregatesForEco, id="EVTYPE")
meltAggregatesEcoSorted <- meltAggregatesEco[order(meltAggregatesEco$value, decreasing=TRUE),]
  
cropDamageTop10 <- meltAggregatesEcoSorted[meltAggregatesEcoSorted$variable == "cropDmgAmountTotal",][1:10,]
cropDamageTop10 <- transform(cropDamageTop10, EVTYPE = reorder(EVTYPE, value))
propDamageTop10 <- meltAggregatesEcoSorted[meltAggregatesEcoSorted$variable == "propDmgAmountTotal",][1:10,]
propDamageTop10 <- transform(propDamageTop10, EVTYPE = reorder(EVTYPE, value))

meltDamageTop10 <- rbind(cropDamageTop10, propDamageTop10)

#meltAggregatesEco <- transform(meltAggregatesEco, EVTYPE = reorder(EVTYPE, value))
#top <- head(meltAggregatesEco[order(meltAggregatesEco$total, decreasing=TRUE),], 40)

# ignore the 1st
g1 <- ggplot(meltDamageTop10, aes(x=EVTYPE, fill=variable, y=value)) + geom_histogram(stat="identity") + coord_flip() + facet_grid(variable ~ ., scales = "free_y")
g1
# Crop damage 
g2 <- ggplot(cropDamageTop10, aes(x=EVTYPE, fill=EVTYPE, y=value)) + geom_histogram(stat="identity") + coord_flip()
g2
# Prop damage
g3 <- ggplot(propDamageTop10, aes(x=EVTYPE, fill=EVTYPE, y=value)) + geom_histogram(stat="identity") + coord_flip()

g3
```

## Supplementary info

```{r}
sessionInfo()
```

